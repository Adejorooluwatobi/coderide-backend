import {\n  WebSocketGateway,\n  WebSocketServer,\n  SubscribeMessage,\n  OnGatewayConnection,\n  OnGatewayDisconnect,\n  MessageBody,\n  ConnectedSocket,\n} from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\nimport { Logger, UseGuards } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { RideTrackingService } from 'src/domain/services/ride-tracking.service';\n\n@WebSocketGateway({\n  cors: {\n    origin: '*',\n  },\n  namespace: '/ride-tracking',\n})\nexport class RideTrackingGateway implements OnGatewayConnection, OnGatewayDisconnect {\n  @WebSocketServer()\n  server: Server;\n\n  private readonly logger = new Logger(RideTrackingGateway.name);\n  private connectedUsers = new Map<string, string>(); // socketId -> userId\n  private userSockets = new Map<string, string>(); // userId -> socketId\n\n  constructor(\n    private jwtService: JwtService,\n    private rideTrackingService: RideTrackingService,\n  ) {}\n\n  async handleConnection(client: Socket) {\n    try {\n      const token = client.handshake.auth.token || client.handshake.headers.authorization?.split(' ')[1];\n      \n      if (!token) {\n        client.disconnect();\n        return;\n      }\n\n      const payload = this.jwtService.verify(token);\n      const userId = payload.sub;\n\n      this.connectedUsers.set(client.id, userId);\n      this.userSockets.set(userId, client.id);\n\n      client.join(`user:${userId}`);\n      \n      this.logger.log(`User ${userId} connected with socket ${client.id}`);\n    } catch (error) {\n      this.logger.error('WebSocket connection error:', error);\n      client.disconnect();\n    }\n  }\n\n  handleDisconnect(client: Socket) {\n    const userId = this.connectedUsers.get(client.id);\n    if (userId) {\n      this.connectedUsers.delete(client.id);\n      this.userSockets.delete(userId);\n      this.logger.log(`User ${userId} disconnected`);\n    }\n  }\n\n  @SubscribeMessage('join-ride')\n  async handleJoinRide(\n    @MessageBody() data: { rideId: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const userId = this.connectedUsers.get(client.id);\n    if (!userId) return;\n\n    client.join(`ride:${data.rideId}`);\n    this.logger.log(`User ${userId} joined ride ${data.rideId}`);\n  }\n\n  @SubscribeMessage('leave-ride')\n  async handleLeaveRide(\n    @MessageBody() data: { rideId: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const userId = this.connectedUsers.get(client.id);\n    if (!userId) return;\n\n    client.leave(`ride:${data.rideId}`);\n    this.logger.log(`User ${userId} left ride ${data.rideId}`);\n  }\n\n  @SubscribeMessage('location-update')\n  async handleLocationUpdate(\n    @MessageBody() data: {\n      rideId: string;\n      latitude: number;\n      longitude: number;\n      speed?: number;\n      heading?: number;\n    },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const userId = this.connectedUsers.get(client.id);\n    if (!userId) return;\n\n    try {\n      // Save tracking point to database\n      await this.rideTrackingService.create({\n        rideId: data.rideId,\n        latitude: data.latitude,\n        longitude: data.longitude,\n        speed: data.speed,\n        heading: data.heading,\n      });\n\n      // Broadcast to all users in the ride\n      this.server.to(`ride:${data.rideId}`).emit('location-updated', {\n        rideId: data.rideId,\n        latitude: data.latitude,\n        longitude: data.longitude,\n        speed: data.speed,\n        heading: data.heading,\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      this.logger.error('Location update error:', error);\n    }\n  }\n\n  // Emit ride status updates\n  emitRideStatusUpdate(rideId: string, status: string, data?: any) {\n    this.server.to(`ride:${rideId}`).emit('ride-status-updated', {\n      rideId,\n      status,\n      data,\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  // Emit notifications to specific user\n  emitNotificationToUser(userId: string, notification: any) {\n    const socketId = this.userSockets.get(userId);\n    if (socketId) {\n      this.server.to(socketId).emit('notification', notification);\n    }\n  }\n}\n